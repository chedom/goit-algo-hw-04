# Порівняння алгоритмів сортування: злиттям, вставками та Timsort за часом виконання
---
## Ціль експерименту порівняти три види алгоритмів сортування:
 - **Insertion sort** (імплементація з LMS)
 - **Merge sort** (імплементація з in place без проміжних list)
 - **Timsort** (вбудований Python метод `sort`)

 Вхідні дані:
 - різний розмір массива ([10, 50, 100, 500, 1000, 5000, 10000])
 - дані у масиві
    - відсортовані
    - відсортовані у зворотньому порядку
    - randomized

Для вимірювання часу виконання використовувався вбудований Python пакет: `timeit`

## Запуск для проведення аналізу
`python3 01_task/main.py`

## Результати тесту

### Відсортовані дані

| N     | Insertion | Merge    | Timsort  |
|------:|----------:|---------:|---------:|
| 10    | 0.000291  | 0.000987 | 0.000015 |
| 50    | 0.000580  | 0.004880 | 0.000024 |
| 100   | 0.000632  | 0.010040 | 0.000061 |
| 500   | 0.003630  | 0.063040 | 0.000140 |
| 1000  | 0.008660  | 0.126124 | 0.000285 |
| 5000  | 0.045587  | 0.728659 | 0.001371 |
| 10000 | 0.099700  | 1.507854 | 0.002685 |


### Відсортовані у зворотньому порядку

| N     | Insertion | Merge    | Timsort  |
|------:|----------:|---------:|---------:|
| 10    | 0.000083  | 0.000824 | 0.000014 |
| 50    | 0.000353  | 0.005028 | 0.000040 |
| 100   | 0.000773  | 0.010043 | 0.000037 |
| 500   | 0.010426  | 0.060909 | 0.000146 |
| 1000  | 0.041504  | 0.123885 | 0.000272 |
| 5000  | 0.926801  | 0.712778 | 0.001411 |
| 10000 | 3.643126  | 1.553048 | 0.002859 |

### Randomized

| N     | Insertion | Merge    | Timsort  |
|------:|----------:|---------:|---------:|
| 10    | 0.000096  | 0.001538 | 0.000037 |
| 50    | 0.001292  | 0.005749 | 0.000028 |
| 100   | 0.000711  | 0.012561 | 0.000043 |
| 500   | 0.007782  | 0.058036 | 0.000177 |
| 1000  | 0.031604  | 0.126690 | 0.000356 |
| 5000  | 0.501480  | 0.724589 | 0.002004 |
| 10000 | 1.978299  | 1.602758 | 0.004851 |


* важливо зазначити, що дані тестування можуть відрізнятись в залежності від конфігурації (CPU, RAM) ПК на якому запущене тестування та його навантаженості іншими конкурентними процесами.

## Аналіз результатів

### Insertion sort
- Для уже відсортованих даних алгоритм працює майже **лінійно** (**O(n)**)
- Для відсортованих даних у зворотному порядку (є найгіршим випадком для алгоритму) та randomized - **квадратична** складність (O(n^2))
- Алгоритм найбільш ефективний для майже відсортованих масивів або малих масивів
- Результати тестування узгоджуються з теорією

### Merge sort
- Майже не залежить від впорядкованості даних
- При невеликих розмірах масивів повільніший ніж Insertion sort
- Час виконання збільшується плавніше (**O(n log n)**), не квадратично, як у випадку з Insertion
- Результати тестування узгоджуються з теорією 

* для імплементації merge sort використовувався алгоритм який не створює проміжних масивів (імплементація з LMS), в іншому випадку даний алгоритм буде найповільніший


### Timsort
- Майже не залежить від впорядкованості даних
- Найшвидший у проведених benchmarks
- При збільшені к-сті елементів у массиві час зростає не лінійно, але повільніше (**O(n log n)**) ніж у merge sort
- Результати тестування узгоджуються з теорією

## Висновок
На практиці слід використовувати гібридний алгоритм Timsort, так як він найшвидший у всіх випадках, в не залежності від розміру масиву чи впорядкованості даних у ньому (при малих розмірах масиву різниця практично не помітна).